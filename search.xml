<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于Stream流</title>
      <link href="/2024/02/25/Unity/%E5%BA%8F%E5%88%97%E5%8C%96/%E5%85%B3%E4%BA%8EStream%E6%B5%81/"/>
      <url>/2024/02/25/Unity/%E5%BA%8F%E5%88%97%E5%8C%96/%E5%85%B3%E4%BA%8EStream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Stream"><a href="#关于Stream" class="headerlink" title="关于Stream"></a>关于Stream</h1><p><code>Stream stream = response.GetResponseStream()</code>在Unity 2022版本中，<code>Stream</code>对象不再直接提供<code>Length</code>属性来获取流的长度。相反，您可以使用<code>Stream</code>对象的其他方法来获取流的长度。在Unity 2019版本中可以正常使用<code>Length</code>属性，这可能是由于Unity使用了不同的解析器或实现方式。您可以通过使用<code>stream.Read</code>方法来迭代流的内容，并计算读取的字节数来获得流的长度。另外，还可以使用<code>stream.Seek</code>方法将流的位置设置到流的末尾，然后使用<code>stream.Position</code>属性来获取流的长度。这两种方法都能在Unity 2022版本中获得流的长度。<br>在Unity 2022版本中，获取<code>Response Stream</code>的长度可以使用以下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream stream = response.GetResponseStream();</span><br><span class="line"><span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">4096</span>]; <span class="comment">// 缓冲区大小可以根据需要进行调整</span></span><br><span class="line"><span class="built_in">int</span> totalBytesRead = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> bytesRead;</span><br><span class="line"><span class="keyword">while</span> ((bytesRead = stream.Read(buffer, <span class="number">0</span>, buffer.Length)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    totalBytesRead += bytesRead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> streamLength = totalBytesRead;</span><br></pre></td></tr></table></figure><p>上述代码创建了一个缓冲区，并使用<code>stream.Read()</code>方法循环读取数据，不断累加已读取的字节数。最后，<code>streamLength</code>变量将保存<code>Response Stream</code>的长度。请注意，此方法适用于读取二进制数据流。如需获取文本数据流的长度，可根据具体情况将缓冲区设置为适当的文本编码。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> 序列化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>判断UI元素超出屏幕</title>
      <link href="/2024/02/25/Unity/UI/%E5%88%A4%E6%96%ADUI%E5%85%83%E7%B4%A0%E8%B6%85%E5%87%BA%E5%B1%8F%E5%B9%95/"/>
      <url>/2024/02/25/Unity/UI/%E5%88%A4%E6%96%ADUI%E5%85%83%E7%B4%A0%E8%B6%85%E5%87%BA%E5%B1%8F%E5%B9%95/</url>
      
        <content type="html"><![CDATA[<p>这里只判断UI元素的RectTransform，不判断实际UI元素实际绘制区域，代码如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> halfW = <span class="number">121</span></span><br><span class="line"><span class="keyword">local</span> halfH = <span class="number">50</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideDesPosView:CalcUiBound</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">self</span>.m_desPos <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">local</span> value = Camera.main:WorldToScreenPoint(<span class="built_in">self</span>.m_desPos)</span><br><span class="line">  <span class="keyword">local</span> x = value.x</span><br><span class="line">  <span class="keyword">local</span> y = value.y</span><br><span class="line">  <span class="keyword">local</span> z = value.z</span><br><span class="line">  <span class="keyword">if</span> x == <span class="built_in">self</span>.m_lastX <span class="keyword">and</span> y == <span class="built_in">self</span>.m_lastY <span class="keyword">and</span> z == <span class="built_in">self</span>.m_lastZ <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> z &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.contentTrans.gameObject.activeSelf <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">self</span>.contentTrans.gameObject:SetActive(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">elseif</span> z &gt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.m_lastZ &gt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">self</span>.contentTrans.gameObject:SetActive(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">local</span> scaleX = <span class="number">1920</span> / Screen.width</span><br><span class="line">  <span class="keyword">local</span> scaleY = <span class="number">1080</span> / Screen.height</span><br><span class="line"></span><br><span class="line">  <span class="built_in">self</span>.m_lastX = x</span><br><span class="line">  <span class="built_in">self</span>.m_lastY = y</span><br><span class="line">  <span class="built_in">self</span>.m_lastZ = z</span><br><span class="line">  <span class="keyword">if</span> (value.x + halfW &gt; Screen.width) <span class="keyword">then</span></span><br><span class="line">    x = Screen.width - halfW</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (value.x - halfW &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    x = halfW</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (value.y - halfH &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    y = halfH</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (value.y + halfH &gt; Screen.height) <span class="keyword">then</span></span><br><span class="line">    y = Screen.height - halfH</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">self</span>.contentRectTrans.localPosition = Vector3((x - Screen.width / <span class="number">2</span>) * scaleX, (y - Screen.height / <span class="number">2</span>) * scaleY, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Untiy性能优化小结</title>
      <link href="/2024/02/25/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Untiy%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/"/>
      <url>/2024/02/25/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Untiy%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="MemeoryProfiler-dddd"><a href="#MemeoryProfiler-dddd" class="headerlink" title="MemeoryProfiler dddd"></a>MemeoryProfiler dddd</h1><p>在Unity中，Memory Profiler（内存分析器）提供了Compare Snapshots（比较快照）功能，用于比较两个不同时间点的内存快照数据。通过比较内存快照，可以了解对象在不同时间点的内存使用情况，帮助进行内存优化和泄漏调试。</p><p>在使用Memory Profiler的Compare Snapshots功能时，可以设置是否启用Managed选项。Managed选项用于指定是否包含托管堆（managed heap）中的数据。默认情况下，Managed选项是启用的，这表示内存快照会包括托管堆中的对象信息。</p><p>如果禁用了Managed选项，比较快照时将不会包含托管堆中的对象信息，只会分析非托管资源的内存使用情况。这在一些特定的情况下可能会更有用，例如只关注引起内存泄漏的非托管资源时。</p><p>通过在Memory Profiler中使用Compare Snapshots功能，并根据需求选择启用或禁用Managed选项，能更好地识别和解决游戏中的内存问题，提升Unity项目的性能和效率。</p><img src="/postimg/Unity性能优化/MemeoryProfiler.png" alt="Memory Profiler" width="500" height="400">]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> Unity性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL资料</title>
      <link href="/2024/02/25/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/OpenGL%E8%B5%84%E6%96%99/"/>
      <url>/2024/02/25/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/OpenGL%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形渲染 </category>
          
          <category> 资料推荐 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
